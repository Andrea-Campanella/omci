/*
 * Copyright (c) 2018 - present.  Boling Consulting Solutions (bcsw.net)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * NOTE: This file was generated, manual edits will be overwritten!
 *
 * Generated by 'goCodeGenerator.py':
 *              https://github.com/cboling/OMCI-parser/README.md
 */
package omci

import (
	me "./generated"
	"errors"
	"fmt"
)

type options struct {
	frameFormat     	DeviceIdent
	failIfTruncated 	bool
	attributeMask   	uint16
	results         	me.Results	 // Common for many responses
	attrExecutionMask   uint8		 // Create Response Only if results == 3
}

var defaultFrameOptions = options{
	frameFormat:     	BaselineIdent,
	failIfTruncated: 	false,
	attributeMask:   	0xFFFF,
	results:         	me.Success,	// TODO: Add setter funcs for these
	attrExecutionMask: 	0,
}

// A FrameOption sets options such as frame format, etc.
type FrameOption func(*options)

// FrameFormat determines determines the OMCI message format used on the fiber.
// The default value is BaselineIdent
func FrameFormat(ff DeviceIdent) FrameOption {
	return func(o *options) {
		o.frameFormat = ff
	}
}

// FailIfTruncated determines whether a request encode a frame that does not
// have enough room for all requested options should return an error.
//
// If set to 'false', only Attributes that can fit will be encoded into the
// request and if the message type supports it, an appropriate status code
// and failed-attribute-flag fields will be set accordingly
//
// If set to 'true', no object is returned and an error is provided.
//
// The default value is 'false'
func FailIfTruncated(f bool) FrameOption {
	return func(o *options) {
		o.failIfTruncated = f
	}
}

// AttributeMask determines the attributes to encode into the frame.
// The default value is 0xFFFF which specifies all available attributes
// in the frame
func AttributeMask(m uint16) FrameOption {
	return func(o *options) {
		o.attributeMask = m
	}
}

// IManagedEntity provides an interface definition for a simplified ME that can
// be used in a variety of applications (MIB database, ONU driver, OLT application, ...)
// where the serialization into a packet may not always be desired.

type IManagedEntity interface {
	GetClassId() uint16
	GetInstanceId() uint16
	SetInstanceId(uint16) error
	GetAttributesMap() *me.AttributeValueMap
	GetManagedEntityDefinition() (me.IManagedEntityDefinition, error)
	EncodeFrame(messageType me.MsgType, opt ...FrameOption) (*OMCI, interface{}, error)
}

// ManagedEntity is intended to be a lighter weight version of a specific managed
// entity. It is intended to be used by generated Managed Entity classes as a base
// class which is easier to use within an application outside of just decode and
// serialization of OMCI Packets
type ManagedEntity struct {
	ClassId    uint16
	InstanceId uint16
	Attributes me.AttributeValueMap
}

// String provides a simple string that describes this struct
func (m *ManagedEntity) String() string {
	return fmt.Sprintf("ManagedEntity: %v/%v (%#x/%#x): Attributes: %v",
		m.ClassId, m.ClassId, m.InstanceId, m.InstanceId, m.Attributes)
}

// GetManagedEntityDefinition returns a definition of what message types this
// ME supports as well as detailed information on the attributes of this ME.
func (m *ManagedEntity) GetManagedEntityDefinition() (me.IManagedEntityDefinition, error) {
	// Just get definition without validation of parameters
	return me.LoadManagedEntityDefinition(m.ClassId)
}

// EncodeFrame will encode the Managed Entity specific protocol struct and an
// OMCILayer struct. This struct can be provided to the gopacket.SerializeLayers()
// function to be serialized into a buffer for transmission.
func (m *ManagedEntity) EncodeFrame(messageType byte, opt ...FrameOption) (*OMCI, interface{}, error) {
	opts := defaultFrameOptions
	for _, o := range opt {
		o(&opts)
	}
	// Note: Transaction ID should be set before frame serialization
	omci := &OMCI{
		TransactionID:    0,
		MessageType:      messageType,
		DeviceIdentifier: opts.frameFormat,
	}
	var meInfo interface{}
	var err error

	// Encode message type specific operation
	switch messageType {
	case byte(me.Create) | me.AR:
		meInfo, err = m.createRequestFrame(opts)
	case byte(me.Delete) | me.AR:
		meInfo, err = m.deleteRequestFrame(opts)
	case byte(me.Get) | me.AR:
		meInfo, err = m.getRequestFrame(opts)
	case byte(me.GetAllAlarms) | me.AR:
		meInfo, err = m.getAllAlarmsRequestFrame(opts)
	case byte(me.GetAllAlarmsNext) | me.AR:
		meInfo, err = m.getAllAlarmsNextRequestFrame(opts)
	case byte(me.MibUpload) | me.AR:
		meInfo, err = m.mibUploadRequestFrame(opts)
	case byte(me.MibUploadNext) | me.AR:
		meInfo, err = m.mibUploadNextRequestFrame(opts)
	case byte(me.MibReset) | me.AR:
		meInfo, err = m.mibResetRequestFrame(opts)
	case byte(me.Test) | me.AR:
		meInfo, err = m.testRequestFrame(opts)
	case byte(me.StartSoftwareDownload) | me.AR:
		meInfo, err = m.startSoftwareDownloadRequestFrame(opts)
	case byte(me.DownloadSection) | me.AR, byte(me.DownloadSection):
		meInfo, err = m.downloadSectionRequestFrame(opts)
	case byte(me.EndSoftwareDownload) | me.AR:
		meInfo, err = m.endSoftwareDownloadRequestFrame(opts)
	case byte(me.ActivateSoftware) | me.AR:
		meInfo, err = m.activateSoftwareRequestFrame(opts)
	case byte(me.CommitSoftware) | me.AR:
		meInfo, err = m.commitSoftwareRequestFrame(opts)
	case byte(me.SynchronizeTime) | me.AR:
		meInfo, err = m.synchronizeTimeRequestFrame(opts)
	case byte(me.Reboot) | me.AR:
		meInfo, err = m.rebootRequestFrame(opts)
	case byte(me.GetNext) | me.AR:
		meInfo, err = m.getNextRequestFrame(opts)
	case byte(me.GetCurrentData) | me.AR:
		meInfo, err = m.getCurrentDataRequestFrame(opts)
	case byte(me.SetTable) | me.AR:
		meInfo, err = m.setTableRequestFrame(opts)

	// Response Frames
	case byte(me.Create) | me.AK:
		meInfo, err = m.createResponseFrame(opts)
	case byte(me.Delete) | me.AK:
		meInfo, err = m.deleteResponseFrame(opts)
	case byte(me.Get) | me.AK:
		meInfo, err = m.getResponseFrame(opts)
	case byte(me.GetAllAlarms) | me.AK:
		meInfo, err = m.getAllAlarmsResponseFrame(opts)
	case byte(me.GetAllAlarmsNext) | me.AK:
		meInfo, err = m.getAllAlarmsNextResponseFrame(opts)
	case byte(me.MibUpload) | me.AK:
		meInfo, err = m.mibUploadResponseFrame(opts)
	case byte(me.MibUploadNext) | me.AK:
		meInfo, err = m.mibUploadNextResponseFrame(opts)
	case byte(me.MibReset) | me.AK:
		meInfo, err = m.mibResetResponseFrame(opts)
	case byte(me.Test) | me.AK:
		meInfo, err = m.testResponseFrame(opts)
	case byte(me.StartSoftwareDownload) | me.AK:
		meInfo, err = m.startSoftwareDownloadResponseFrame(opts)
	case byte(me.DownloadSection) | me.AK:
		meInfo, err = m.downloadSectionResponseFrame(opts)
	case byte(me.EndSoftwareDownload) | me.AK:
		meInfo, err = m.endSoftwareDownloadResponseFrame(opts)
	case byte(me.ActivateSoftware) | me.AK:
		meInfo, err = m.activateSoftwareResponseFrame(opts)
	case byte(me.CommitSoftware) | me.AK:
		meInfo, err = m.commitSoftwareResponseFrame(opts)
	case byte(me.SynchronizeTime) | me.AK:
		meInfo, err = m.synchronizeTimeResponseFrame(opts)
	case byte(me.Reboot) | me.AK:
		meInfo, err = m.rebootResponseFrame(opts)
	case byte(me.GetNext) | me.AK:
		meInfo, err = m.getNextResponseFrame(opts)
	case byte(me.GetCurrentData) | me.AK:
		meInfo, err = m.getCurrentDataResponseFrame(opts)
	case byte(me.SetTable) | me.AK:
		meInfo, err = m.setTableResponseFrame(opts)

	// Autonomous ONU Frames
	case byte(me.AlarmNotification) | me.AK:
		meInfo, err = m.alarmNotificationFrame(opts)
	case byte(me.AttributeValueChange) | me.AK:
		meInfo, err = m.attributeValueChangeFrame(opts)
	case byte(me.TestResult):
		meInfo, err = m.testResultFrame(opts)

	// Unknown
	default:
		err = errors.New(fmt.Sprintf("message-type: %v/%#x is not supported", messageType, messageType))
	}
	return omci, meInfo, err
}

// For most all create methods below, error checking for valid masks, attribute
// values, and other fields is left to when the frame is actually serialized.

func (m *ManagedEntity) reduceMask(mask uint16) (uint16, error) {
	def, err := m.GetManagedEntityDefinition()
	if err != nil {
		return 0, err
	}
	return mask & def.GetAllowedAttributeMask(), nil
}

// return the maximum space that can be used by attributes
func (m *ManagedEntity) maxPacketAvailable(opt options) uint {
	if opt.frameFormat == BaselineIdent {
		// OMCI Header          - 4 octets
		// Class ID/Instance ID - 4 octets
		// Length field			- 4 octets
		// MIC                  - 4 octets
		return MaxBaselineLength - 16
	}
	// OMCI Header          - 4 octets
	// Class ID/Instance ID - 4 octets
	// Length field			- 4 octets
	// MIC                  - 4 octets
	return MaxExtendedLength - 16
}

func (m *ManagedEntity) createRequestFrame(opt options) (interface{}, error) {
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	return meLayer, nil
}

func (m *ManagedEntity) createResponseFrame(opt options) (interface{}, error) {
	// Common for all MEs
	meLayer := &CreateResponse{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	return meLayer, nil
}

//Delete                MsgType = 6
func (m *ManagedEntity) deleteRequestFrame(opt options) (interface{}, error) {
	// Common for all MEs
	meLayer := &DeleteRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	return meLayer, nil
}

func (m *ManagedEntity) deleteResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) setRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) setResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getAllAlarmsRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getAllAlarmsResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getAllAlarmsNextRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getAllAlarmsNextResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) mibUploadRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) mibUploadResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) mibUploadNextRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) mibUploadNextResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) mibResetRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) mibResetResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) alarmNotificationFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) attributeValueChangeFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) testRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) testResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) startSoftwareDownloadRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) startSoftwareDownloadResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) downloadSectionRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) downloadSectionResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) endSoftwareDownloadRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) endSoftwareDownloadResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) activateSoftwareRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) activateSoftwareResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) commitSoftwareRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) commitSoftwareResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) synchronizeTimeRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) synchronizeTimeResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) rebootRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) rebootResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getNextRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getNextResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) testResultFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getCurrentDataRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) getCurrentDataResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}

func (m *ManagedEntity) setTableRequestFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer, errors.New("todo: Not implemented")
}

func (m *ManagedEntity) setTableResponseFrame(opt options) (interface{}, error) {
	mask, err := m.reduceMask(opt.attributeMask)
	if err != nil {
		return nil, err
	}
	// Common for all MEs
	meLayer := &CreateRequest{
		MeBasePacket: MeBasePacket{
			EntityClass:    m.ClassId,
			EntityInstance: m.InstanceId,
		},
	}
	// Get payload space available
	maxPayload := m.maxPacketAvailable(opt)

	// TODO: Lots of work to do

	fmt.Println(mask, maxPayload)
	return meLayer,  errors.New("todo: Not implemented")
}
